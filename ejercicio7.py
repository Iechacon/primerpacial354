# -*- coding: utf-8 -*-
"""ejercicio7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eKjc1j4DMqGl-uFaWziJolk5K2kWbBrt
"""

pip install deap

import random
from deap import base, creator, tools

# Eliminar las clases creadas anteriormente si existen para evitar advertencias de duplicado
if 'FitnessMax' in creator.__dict__:
    del creator.FitnessMax
if 'Individual' in creator.__dict__:
    del creator.Individual

# Definir la función objetivo: f(x) = x^(2x) - 1
def funcion_objetivo(individuo):
    x = individuo[0]  # El individuo es una lista con un valor de x
    try:
        return (x ** (2 * x)) - 1,
    except OverflowError:
        return float('inf')  # Controlar valores muy grandes

# Crear la estructura del problema: Maximización del fitness
creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

# Definir el Toolbox para los operadores genéticos
toolbox = base.Toolbox()
valores_iniciales = [13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]

# Definir cómo se crea un individuo a partir de los valores iniciales
toolbox.register("attr_value", lambda: random.choice(valores_iniciales))
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_value, n=1)

# Crear la población correctamente con initRepeat para listas de individuos
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# Registrar la función de evaluación correctamente
toolbox.register("evaluate", funcion_objetivo)

# **Registrar la función de selección en el toolbox**
toolbox.register("select", tools.selTournament, tournsize=3)  # Selección por torneo con tamaño 3

# Crear la población inicial
poblacion = toolbox.population(n=len(valores_iniciales))  # Crear la población basada en la longitud de valores_iniciales

# Definir los parámetros del algoritmo genético
prob_cruzamiento = 0.5  # Probabilidad de cruzamiento
prob_mutacion = 0.2     # Probabilidad de mutación
numero_generaciones = 3

# Controlar los puntos de cruce y mutación por cada generación
puntos_cruce = [4, 3, 2]  # Puntos de cruce por generación
bits_mutacion = [3, 6, 5]  # Bits de mutación por generación

# Función para aplicar cruce y mutación con puntos específicos
def aplicar_cruce_mutacion(toolbox, poblacion, punto_cruce, bit_mutacion):
    # Aplicar el cruzamiento en el punto especificado
    for i in range(1, len(poblacion), 2):
        # Cruzar pares de individuos si tienen más de un elemento
        if len(poblacion[i - 1]) > 1 and len(poblacion[i]) > 1:
            tools.cxOnePoint(poblacion[i - 1], poblacion[i])

    # Aplicar la mutación en el bit especificado
    for individuo in poblacion:
        # Cambiar el bit específico de la estructura de individuo
        bin_value = format(individuo[0], '08b')
        lista_bits = list(bin_value)
        # Realizar la mutación en el bit especificado
        lista_bits[bit_mutacion] = '1' if lista_bits[bit_mutacion] == '0' else '0'
        # Convertir el binario mutado a decimal
        individuo[0] = int(''.join(lista_bits), 2)

# Función para evaluar manualmente los valores de aptitud
def evaluar_fitness(poblacion):
    for ind in poblacion:
        ind.fitness.values = funcion_objetivo(ind)  # Remove the extra comma to assign a tuple of numbers

# Evolucionar a lo largo de las generaciones especificadas
for gen in range(numero_generaciones):
    print(f"\n--- Generación {gen + 1} ---")

    # Evaluar manualmente cada individuo en la población
    evaluar_fitness(poblacion)

    # Aplicar selección usando la función registrada en el toolbox
    poblacion = toolbox.select(poblacion, len(poblacion))

    # Aplicar cruce y mutación con los puntos específicos
    aplicar_cruce_mutacion(toolbox, poblacion, puntos_cruce[gen], bits_mutacion[gen])

    # Evaluar nuevamente la población
    evaluar_fitness(poblacion)

    # Mostrar la población y sus fitness después de cada generación
    for ind in poblacion:
        print(f"Individuo: {ind}, Fitness: {ind.fitness.values[0]}")

# Seleccionar el mejor individuo después de todas las generaciones
mejor_individuo = tools.selBest(poblacion, k=1)[0]
print(f"\nMejor Individuo: {mejor_individuo}, Fitness: {mejor_individuo.fitness.values[0]}")

# Definir la población inicial según la imagen proporcionada
poblacion_inicial = [13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]

# Definir la función de evaluación f(x) = x^(2x) - 1
def funcion_evaluacion(x):
    try:
        return x ** (2 * x) - 1
    except OverflowError:  # Controlar errores por valores grandes
        return float('inf')

# Función para realizar cruce de individuos en un punto específico
def realizar_cruce(poblacion, punto_de_cruce):
    poblacion_cruzada = []
    for i in range(0, len(poblacion), 2):  # Iterar en pares
        padre1 = poblacion[i]
        padre2 = poblacion[i + 1] if i + 1 < len(poblacion) else poblacion[0]  # Evitar out of range
        # Realizar el cruce en el punto especificado
        hijo1 = padre1[:punto_de_cruce] + padre2[punto_de_cruce:]
        hijo2 = padre2[:punto_de_cruce] + padre1[punto_de_cruce:]
        poblacion_cruzada.extend([hijo1, hijo2])
    return poblacion_cruzada

# Función para realizar mutación en un punto específico
def realizar_mutacion(poblacion, indice_mutacion):
    poblacion_mutada = []
    for individuo in poblacion:
        lista_bits = list(individuo)
        # Mutar el bit en el índice especificado
        lista_bits[indice_mutacion] = '1' if lista_bits[indice_mutacion] == '0' else '0'
        poblacion_mutada.append(''.join(lista_bits))
    return poblacion_mutada

# Primera Generación
# Paso 1: Evaluar la función para cada valor de la población inicial
evaluaciones_gen1 = [funcion_evaluacion(x) for x in poblacion_inicial]

# Paso 2: Convertir cada valor de la población a su representación binaria de 8 bits
fenotipos_gen1 = [format(x, '08b') for x in poblacion_inicial]

# Paso 3: Realizar cruce y mutación para la primera generación (Punto de cruce: 3, Mutación: 4to bit)
cruce_gen1 = realizar_cruce(fenotipos_gen1, punto_de_cruce=3)
mutacion_gen1 = realizar_mutacion(cruce_gen1, indice_mutacion=3)
poblacion_final_gen1 = [int(ind, 2) for ind in mutacion_gen1]

# Segunda Generación (Usar la población final de la 1ra generación)
evaluaciones_gen2 = [funcion_evaluacion(x) for x in poblacion_final_gen1]
fenotipos_gen2 = [format(x, '08b') for x in poblacion_final_gen1]
# Realizar cruce y mutación para la segunda generación (Punto de cruce: 4, Mutación: 6to bit)
cruce_gen2 = realizar_cruce(fenotipos_gen2, punto_de_cruce=4)
mutacion_gen2 = realizar_mutacion(cruce_gen2, indice_mutacion=5)
poblacion_final_gen2 = [int(ind, 2) for ind in mutacion_gen2]

# Tercera Generación (Usar la población final de la 2da generación)
evaluaciones_gen3 = [funcion_evaluacion(x) for x in poblacion_final_gen2]
fenotipos_gen3 = [format(x, '08b') for x in poblacion_final_gen2]
# Realizar cruce y mutación para la tercera generación (Punto de cruce: 2, Mutación: 5to bit)
cruce_gen3 = realizar_cruce(fenotipos_gen3, punto_de_cruce=2)
mutacion_gen3 = realizar_mutacion(cruce_gen3, indice_mutacion=4)
poblacion_final_gen3 = [int(ind, 2) for ind in mutacion_gen3]

# Mostrar los resultados de cada generación
import pandas as pd

# Crear DataFrames para cada generación
df_gen1 = pd.DataFrame({
    'Poblacion Inicial': poblacion_inicial,
    'f(x)': evaluaciones_gen1,
    'Fenotipo (Binario)': fenotipos_gen1,
    'Cruce': cruce_gen1,
    'Mutacion': mutacion_gen1,
    'Poblacion Final (Decimal)': poblacion_final_gen1
})

df_gen2 = pd.DataFrame({
    'Poblacion Inicial': poblacion_final_gen1,
    'f(x)': evaluaciones_gen2,
    'Fenotipo (Binario)': fenotipos_gen2,
    'Cruce': cruce_gen2,
    'Mutacion': mutacion_gen2,
    'Poblacion Final (Decimal)': poblacion_final_gen2
})

df_gen3 = pd.DataFrame({
    'Poblacion Inicial': poblacion_final_gen2,
    'f(x)': evaluaciones_gen3,
    'Fenotipo (Binario)': fenotipos_gen3,
    'Cruce': cruce_gen3,
    'Mutacion': mutacion_gen3,
    'Poblacion Final (Decimal)': poblacion_final_gen3
})

print("Generacion 1:")
print(df_gen1)
print("\nGeneracion 2:")
print(df_gen2)
print("\nGeneracion 3:")
print(df_gen3)